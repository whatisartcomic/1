<!DOCTYPE html>
<html lang="en">
<head>
  <script> document.documentElement.classList.add('ready');</script>
  <style>    html { visibility: hidden; }
    html.ready { visibility: visible; }</style>
  <meta charset="UTF-8">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Borel&display=swap" rel="stylesheet">
  <title>WHAT IS ART?</title> 
  <link rel="stylesheet" href="style.css">


<!-- Apple touch icon (for iOS home‐screen bookmarks) -->
<link rel="apple-touch-icon" sizes="180x180" href="/1/apple-touch-icon.png">

<!-- Standard favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="/1/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/1/favicon-16x16.png">

<!-- Android Chrome icons (used by some Android browsers and PWA installers) -->
<link rel="icon" type="image/png" sizes="192x192" href="/1/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/1/android-chrome-512x512.png">

<!-- Web app manifest (for PWA metadata) -->
<link rel="manifest" href="/1/site.webmanifest">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/favicon.ico">

<!-- Theme color for mobile address‐bar -->
<meta name="theme-color" content="#ffffff">

  
</head>
<body>
  <div id="gallery">
    
    <div id="flipbook" style="visibility: hidden;"></div>
    <div class="haiku">
      <p id="haikuDisplay"></p>
    </div>
    <button id="nextBtn">?</button>
  </div>

<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
  <!-- 2. Turn.js -->
  <script src="turn.js"></script>
  <!-- 3. Logic -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="script.js"></script>
    <script>
    // 1) Helper: pick the “best” available English voice
    function getBestEnglishVoice(voices) {
      const premium = voices
        .filter(v => v.lang.startsWith('en') && /(Google|Microsoft|Alex|Samantha)/i.test(v.name))
        .sort((a, b) => a.name.localeCompare(b.name));
      if (premium.length) return premium[0];
      const fallback = voices.filter(v => v.lang.startsWith('en'));
      return fallback.length ? fallback[0] : null;
    }

    // 2) The function that actually gathers text and speaks it
    function speakPageText() {
      if (!('speechSynthesis' in window)) return;

      const allVoices = window.speechSynthesis.getVoices();
      const chosenVoice = getBestEnglishVoice(allVoices);
      if (!chosenVoice) return;

      // Take only visible text under #mainContent (or you could use body)
      const container = document.getElementById('mainContent');
      const textToSpeak = container.innerText.trim();
      if (!textToSpeak) return;

      const utter = new SpeechSynthesisUtterance(textToSpeak);
      utter.voice = chosenVoice;
      // Tweak these if you like:
      // utter.rate  = 0.95;
      // utter.pitch = 1.1;

      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    // 3) Once voices load, run an initial speak (in case content was already there)
    function trySpeakingImmediately() {
      // Some browsers load voices asynchronously
      if (window.speechSynthesis.getVoices().length) {
        speakPageText();
      }
    }
    if ('speechSynthesis' in window) {
      window.speechSynthesis.onvoiceschanged = trySpeakingImmediately;
      document.addEventListener('DOMContentLoaded', () => {
        setTimeout(trySpeakingImmediately, 500);
      });
    }

    // 4) Observe #mainContent for new nodes or text changes
    const targetNode = document.getElementById('haikuDisplay');
    const observerConfig = {
      childList: true,       // watch for added/removed children
      subtree: true,         // watch all descendants
      characterData: true    // watch for text changes
    };

    // Throttle speaking: if multiple mutations fire in quick succession, only speak once
    let speakTimeout = null;
    const throttledSpeak = () => {
      if (speakTimeout) clearTimeout(speakTimeout);
      // Wait 250ms after the last mutation before speaking
      speakTimeout = setTimeout(() => {
        speakPageText();
        speakTimeout = null;
      }, 250);
    };

    // Only start observing once #mainContent exists
    if (targetNode) {
      const observer = new MutationObserver(() => {
        throttledSpeak();
      });
      observer.observe(targetNode, observerConfig);
    }
  </script>
</body>
</html>
