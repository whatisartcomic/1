<!DOCTYPE html>
<html lang="en">
<head>
  <script> document.documentElement.classList.add('ready');</script>
  <style>    html { visibility: hidden; }
    html.ready { visibility: visible; }</style>
  <meta charset="UTF-8">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Borel&display=swap" rel="stylesheet">
  <title>WHAT IS ART?</title> 
  <link rel="stylesheet" href="style.css">


<!-- Apple touch icon (for iOS home‐screen bookmarks) -->
<link rel="apple-touch-icon" sizes="180x180" href="/1/apple-touch-icon.png">

<!-- Standard favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="/1/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/1/favicon-16x16.png">

<!-- Android Chrome icons (used by some Android browsers and PWA installers) -->
<link rel="icon" type="image/png" sizes="192x192" href="/1/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/1/android-chrome-512x512.png">

<!-- Web app manifest (for PWA metadata) -->
<link rel="manifest" href="/1/site.webmanifest">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/favicon.ico">

<!-- Theme color for mobile address‐bar -->
<meta name="theme-color" content="#ffffff">

  
</head>
<body>
  <div id="gallery">
    
    <div id="flipbook" style="visibility: hidden;"></div>
    <div class="haiku">
      <p id="haikuDisplay"></p>
    </div>
    <button id="nextBtn">?</button>
  </div>

<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
  <!-- 2. Turn.js -->
  <script src="turn.js"></script>
  <!-- 3. Logic -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="script.js"></script>
 <script src="script.js"></script>

  <!-- ────────────────────────────────────────────────────────────────── -->
  <!-- ▼ START: TTS Warm-Up + Auto-Speak on AJAX Updates (no API key) ▼ -->
  <script>
    // ─── 1) Pick a “soft” English voice if available ─────────────────────────❍
    function getSoftEnglishVoice(voices) {
      // Look first for Samantha/Zira/Linda/Amy (common on many systems)
      const soft = voices
        .filter(v => v.lang.startsWith('en') && /(Samantha|Zira|Linda|Amy)/i.test(v.name))
        .sort((a, b) => a.name.localeCompare(b.name));
      if (soft.length) return soft[0];

      // Otherwise fallback to the first English-language voice
      const fallback = voices.filter(v => v.lang.startsWith('en'));
      return fallback.length ? fallback[0] : null;
    }

    // ─── 2) Return a Promise that resolves once speechSynthesis.getVoices() ≠ [] ──❍
    function waitForVoices() {
      return new Promise(resolve => {
        const available = window.speechSynthesis.getVoices();
        if (available.length) {
          resolve(available);
        } else {
          // onvoiceschanged fires when the browser finishes loading its voices
          window.speechSynthesis.onvoiceschanged = () => {
            const now = window.speechSynthesis.getVoices();
            if (now.length) {
              resolve(now);
            }
          };
        }
      });
    }

    // ─── 3) Do one tiny “warm-up” utterance at volume = 0.01 to fully initialize ─❍
    function warmUpTtsEngine(chosenVoice) {
      return new Promise(resolve => {
        // We use a single “.” character at volume=0.01 so it is effectively inaudible,
        // but forces the browser’s TTS engine to decode and load that voice fully.
        const warmup = new SpeechSynthesisUtterance('WHAT IS ART?');
        warmup.voice  = chosenVoice;
        warmup.volume = 0.1; // 10% volume (almost silent)
        warmup.rate   = 1;    // normal rate
        warmup.pitch  = 1;    // normal pitch

        // As soon as this silent utterance ends, we know the engine is warmed up.
        warmup.onend = () => resolve();

        window.speechSynthesis.speak(warmup);
      });
    }

    // ─── 4) Synchronous function: grab #haikuDisplay.innerText and speak it ───❍
    function speakHaikuText() {
      if (!chosenVoice) return;                   // if TTS isn’t ready yet
      const container = document.getElementById('haikuDisplay');
      if (!container) return;

      const text = container.innerText.trim();
      if (!text) return;

      const utter = new SpeechSynthesisUtterance(text);
      utter.voice = chosenVoice;

      // Softening parameters:
      utter.rate   = 0.85; // 15% slower
      utter.pitch  = 0.9;  // slightly lower
      utter.volume = 0.8;  // 80% volume

      // Cancel any in-progress speech so they don’t overlap
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    // ─── 5) Global var to hold the chosen TTS voice ─────────────────────────────❍
    let chosenVoice = null;

    // ─── 6) Chain: wait for voices → choose voice → warm up engine → then wait for initial text → speak ─❍
    const voicePromise   = waitForVoices();
    const contentPromise = new Promise(resolve => {
      const container = document.getElementById('haikuDisplay');
      if (!container) { 
        // If no container exists, just resolve so we don’t hang
        resolve();
        return;
      }
      if (container.innerText.trim()) {
        // If there’s already text, resolve immediately
        resolve();
      } else {
        // Otherwise, observe until some text appears
        const observer = new MutationObserver(() => {
          if (container.innerText.trim()) {
            observer.disconnect();
            resolve();
          }
        });
        observer.observe(container, {
          childList: true,
          subtree: true,
          characterData: true
        });
      }
    });

    voicePromise
      .then(voices => {
        // 6a) Choose and lock in the soft voice
        chosenVoice = getSoftEnglishVoice(voices);
        if (!chosenVoice) {
          console.warn('No suitable English voice found.');
          throw new Error('No voice');
        }
        // 6b) Warm up the engine with a nearly silent utterance
        return warmUpTtsEngine(chosenVoice);
      })
      .then(() => {
        // 6c) Once warm-up is finished, wait for your first haiku to appear
        return contentPromise;
      })
      .then(() => {
        // 6d) Delay a tiny bit (e.g. 50ms) so the browser can render that text
        setTimeout(() => {
          speakHaikuText();
        }, 50);
      })
      .catch(err => {
        // If something fails (no TTS, etc.), we simply won’t speak on page load
        console.error('TTS setup error:', err);
      });

    // ─── 7) Observe #haikuDisplay to re-speak on every AJAX/text change ─────────❍
    (function observeHaikuChanges() {
      const target = document.getElementById('haikuDisplay');
      if (!target) return;

      let throttleTimeout = null;
      const onMutation = () => {
        if (throttleTimeout) clearTimeout(throttleTimeout);
        throttleTimeout = setTimeout(() => {
          // Wait 50ms for DOM painting, then speak
          setTimeout(speakHaikuText, 50);
          throttleTimeout = null;
        }, 200); // 200ms throttle in case of rapid multiple DOM updates
      };

      const observerConfig = {
        childList: true,      // new/removed child nodes
        subtree: true,        // changes anywhere under it
        characterData: true   // text node updates
      };

      const observer = new MutationObserver(onMutation);
      observer.observe(target, observerConfig);
    })();
  </script>


</body>
</html>
