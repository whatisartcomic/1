<!DOCTYPE html>
<html lang="en">
<head>
  <script> document.documentElement.classList.add('ready');</script>
  <style>    html { visibility: hidden; }
    html.ready { visibility: visible; }</style>
  <meta charset="UTF-8">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Borel&display=swap" rel="stylesheet">
  <title>WHAT IS ART?</title> 
  <link rel="stylesheet" href="style.css">


<!-- Apple touch icon (for iOS home‐screen bookmarks) -->
<link rel="apple-touch-icon" sizes="180x180" href="/1/apple-touch-icon.png">

<!-- Standard favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="/1/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/1/favicon-16x16.png">

<!-- Android Chrome icons (used by some Android browsers and PWA installers) -->
<link rel="icon" type="image/png" sizes="192x192" href="/1/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/1/android-chrome-512x512.png">

<!-- Web app manifest (for PWA metadata) -->
<link rel="manifest" href="/1/site.webmanifest">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/favicon.ico">

<!-- Theme color for mobile address‐bar -->
<meta name="theme-color" content="#ffffff">

  
</head>
<body>
  <div id="gallery">
    
    <div id="flipbook" style="visibility: hidden;"></div>
    <div class="haiku">
      <p id="haikuDisplay"></p>
    </div>
    <button id="nextBtn">?</button>
  </div>

<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
  <!-- 2. Turn.js -->
  <script src="turn.js"></script>
  <!-- 3. Logic -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="script.js"></script>
<script>
  // ─── 1) Helper: pick a “soft” English voice if available ─────────────────❍
  function getSoftEnglishVoice(voices) {
    // Prefer a gentle female-sounding name (common on many OSes):
    // “Samantha”, “Zira”, “Linda”, “Amy”, etc.
    const soft = voices
      .filter(v => v.lang.startsWith('en') && /(Samantha|Zira|Linda|Amy)/i.test(v.name))
      .sort((a, b) => a.name.localeCompare(b.name));
    if (soft.length) return soft[0];

    // Fallback to the first English-language voice
    const fallback = voices.filter(v => v.lang.startsWith('en'));
    return fallback.length ? fallback[0] : null;
  }

  // ─── 2) Return a Promise that resolves once voices are loaded ────────────❍
  function waitForVoices() {
    return new Promise(resolve => {
      const loaded = window.speechSynthesis.getVoices();
      if (loaded.length) {
        resolve(loaded);
      } else {
        // Browser will fire onvoiceschanged once voices populate
        window.speechSynthesis.onvoiceschanged = () => {
          const now = window.speechSynthesis.getVoices();
          if (now.length) {
            resolve(now);
          }
        };
      }
    });
  }

  // ─── 3) Return a Promise that resolves once #haikuDisplay has nonempty text ─❍
  function waitForInitialContent() {
    return new Promise(resolve => {
      const container = document.getElementById('haikuDisplay');
      if (!container) {
        // If the element doesn’t exist, we can’t proceed—resolve anyway so we don't hang.
        resolve();
        return;
      }

      // If there’s already text there, resolve immediately:
      if (container.innerText.trim()) {
        resolve();
        return;
      }

      // Otherwise, observe until something appears:
      const observer = new MutationObserver(() => {
        if (container.innerText.trim()) {
          observer.disconnect();
          resolve();
        }
      });
      observer.observe(container, {
        childList: true,
        subtree: true,
        characterData: true
      });
    });
  }

  // ─── 4) Lock in the chosenVoice once both voice + initial content are ready ──❍
  let chosenVoice = null;
  const voiceReadyPromise    = waitForVoices();
  const firstContentPromise  = waitForInitialContent();

  Promise.all([voiceReadyPromise, firstContentPromise]).then(values => {
    const voices = values[0] || window.speechSynthesis.getVoices();
    chosenVoice  = getSoftEnglishVoice(voices);
    if (!chosenVoice) {
      console.warn('No suitable English voice found.');
      return;
    }
    // Now that both a voice is ready and the first haiku has arrived, speak it:
    speakHaikuText();
  });

  // ─── 5) Synchronous function to read whatever is currently in #haikuDisplay ─❍
  function speakHaikuText() {
    // If chosenVoice is not set yet, bail:
    if (!chosenVoice) return;

    const container = document.getElementById('haikuDisplay');
    if (!container) return;

    const textToSpeak = container.innerText.trim();
    if (!textToSpeak) return;

    // Build a new utterance each time (reusing chosenVoice):
    const utter = new SpeechSynthesisUtterance(textToSpeak);
    utter.voice = chosenVoice;

    // Softening parameters:
    utter.rate   = 0.85; // 15% slower
    utter.pitch  = 0.9;  // slightly lower
    utter.volume = 0.8;  // 80% volume

    // Cancel any ongoing speech, then speak:
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
  }

  // ─── 6) Observe #haikuDisplay to re-speak on every AJAX/text change ──────❍
  (function observeHaikuChanges() {
    const targetNode = document.getElementById('haikuDisplay');
    if (!targetNode) return;

    let throttleTimeout = null;
    const throttledSpeak = () => {
      if (throttleTimeout) clearTimeout(throttleTimeout);
      throttleTimeout = setTimeout(() => {
        speakHaikuText();
        throttleTimeout = null;
      }, 250);
    };

    const observerConfig = {
      childList: true,      // watch for new/removed child nodes
      subtree: true,        // watch any descendant changes
      characterData: true   // watch text node updates
    };

    const observer = new MutationObserver(throttledSpeak);
    observer.observe(targetNode, observerConfig);
  })();
</script>


</body>
</html>
