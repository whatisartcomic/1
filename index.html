<!DOCTYPE html>
<html lang="en">
<head>
  <script> document.documentElement.classList.add('ready');</script>
  <style>    html { visibility: hidden; }
    html.ready { visibility: visible; }</style>
  <meta charset="UTF-8">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Borel&display=swap" rel="stylesheet">
  <title>WHAT IS ART?</title> 
  <link rel="stylesheet" href="style.css">


<!-- Apple touch icon (for iOS home‐screen bookmarks) -->
<link rel="apple-touch-icon" sizes="180x180" href="/1/apple-touch-icon.png">

<!-- Standard favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="/1/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/1/favicon-16x16.png">

<!-- Android Chrome icons (used by some Android browsers and PWA installers) -->
<link rel="icon" type="image/png" sizes="192x192" href="/1/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="/1/android-chrome-512x512.png">

<!-- Web app manifest (for PWA metadata) -->
<link rel="manifest" href="/1/site.webmanifest">

<!-- Fallback for older browsers -->
<link rel="shortcut icon" href="/favicon.ico">

<!-- Theme color for mobile address‐bar -->
<meta name="theme-color" content="#ffffff">

  
</head>
<body>
  <div id="gallery">
    
    <div id="flipbook" style="visibility: hidden;"></div>
    <div class="haiku">
      <p id="haikuDisplay"></p>
    </div>
    <button id="nextBtn">?</button>
  </div>

<script
  src="https://code.jquery.com/jquery-3.7.1.min.js"
  integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
  crossorigin="anonymous"></script>
  <!-- 2. Turn.js -->
  <script src="turn.js"></script>
  <!-- 3. Logic -->
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  <script src="script.js"></script>
    <script>
  // ─── 1) Helper: pick the “best” available English voice ─────────────────❍
  function getBestEnglishVoice(voices) {
    // First look for voices whose name includes Google/Microsoft/Alex/Samantha
    const premium = voices
      .filter(v => v.lang.startsWith('en') && /(Google|Microsoft|Alex|Samantha)/i.test(v.name))
      .sort((a, b) => a.name.localeCompare(b.name));
    if (premium.length) return premium[0];

    // Otherwise fall back to the first English-language voice
    const fallback = voices.filter(v => v.lang.startsWith('en'));
    return fallback.length ? fallback[0] : null;
  }

  // ─── 2) Return a Promise that resolves once at least one voice is available ───❍
  function waitForVoices() {
    return new Promise(resolve => {
      const loaded = window.speechSynthesis.getVoices();
      if (loaded.length) {
        resolve(loaded);
      } else {
        // If voices aren’t ready, listen for onvoiceschanged
        window.speechSynthesis.onvoiceschanged = () => {
          const now = window.speechSynthesis.getVoices();
          if (now.length) {
            resolve(now);
          }
        };
      }
    });
  }

  // ─── 3) Grab the <p id="haikuDisplay"> text and speak it ──────────────────❍
  async function speakHaikuText() {
    // 3a) If the browser doesn’t support speechSynthesis, bail
    if (!('speechSynthesis' in window)) return;

    // 3b) Wait until voices are loaded
    const voices = await waitForVoices();
    const chosenVoice = getBestEnglishVoice(voices);
    if (!chosenVoice) return;

    // 3c) Grab the text from #haikuDisplay (or bail if the element is missing)
    const container = document.getElementById('haikuDisplay');
    if (!container) return;

    const textToSpeak = container.innerText.trim();
    if (!textToSpeak) return; // nothing to read

    // 3d) Build and speak the utterance
    const utter = new SpeechSynthesisUtterance(textToSpeak);
    utter.voice = chosenVoice;
    // Optionally tweak rate/pitch:
    // utter.rate  = 0.95;   // 0.1–10 (slower than default)
    // utter.pitch = 1.1;    // 0–2 (slightly higher than default)
  utter.rate   = 0.8;   // 20% slower than default (0.1–10; default is 1)
  utter.pitch  = 0.9;   // Slightly lower pitch (0–2; default is 1)
  utter.volume = 0.8;   // 80% of max volume (0–1; default is 1)
    // Cancel any in-progress speech so they don’t overlap
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(utter);
  }

  // ─── 4) On initial page load, give the DOM a moment, then speak once ───────❍
  document.addEventListener('DOMContentLoaded', () => {
    // Wait 100ms to let any synchronous JS finish injecting initial content
    setTimeout(speakHaikuText, 100);
  });

  // ─── 5) Observe #haikuDisplay and re-speak whenever its text changes ─────❍
  (function observeHaikuChanges() {
    const targetNode = document.getElementById('haikuDisplay');
    if (!targetNode) return;

    // We'll batch rapid changes so we only call speakHaikuText() once per “burst”
    let throttleTimeout = null;
    const throttledSpeak = () => {
      if (throttleTimeout) clearTimeout(throttleTimeout);
      throttleTimeout = setTimeout(() => {
        speakHaikuText();
        throttleTimeout = null;
      }, 250);
    };

    const observerConfig = {
      childList: true,      // watch for new/removed child nodes
      subtree: true,        // watch any descendant changes
      characterData: true   // watch text node updates
    };

    const observer = new MutationObserver(throttledSpeak);
    observer.observe(targetNode, observerConfig);
  })();
</script>

</body>
</html>
